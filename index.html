<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML テトリス</title>
    <!-- Tailwind CSSとGoogle Fontsを読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        :root {
            --board-bg: #0a0a0a;
            --grid-color: #222;
            --text-color: #eee;
            --accent-color: #00ffdd;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: manipulation; /* ダブルタップによるズームを無効化 */
        }

        /* ゲームキャンバスのピクセル化レンダリング */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* カスタムボタンのスタイル */
        .control-btn, .action-btn {
            transition: all 0.1s ease;
            user-select: none; /* ボタンのテキスト選択を無効化 */
        }
        .control-btn:active, .action-btn:active {
            transform: scale(0.95);
        }
        .action-btn:active {
             background-color: #4f46e5;
        }
    </style>
</head>
<body class="bg-gray-900 text-[var(--text-color)] flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-2xl sm:text-4xl text-center mb-4 text-[var(--accent-color)] tracking-wider">TETRIS</h1>

        <!-- ゲーム全体のコンテナ -->
        <div class="flex flex-col md:flex-row justify-center items-start gap-4">

            <!-- ゲームボード -->
            <div class="relative">
                <canvas id="gameCanvas" class="border-2 border-gray-700 rounded-lg shadow-2xl shadow-cyan-500/20"></canvas>
                <!-- ゲームオーバー/スタート画面 -->
                <div id="overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center rounded-lg p-4">
                    <div id="startScreen">
                        <h2 class="text-3xl text-yellow-400 mb-4">Ready?</h2>
                        <button id="startButton" class="action-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-md text-xl animate-pulse">
                            START
                        </button>
                    </div>
                    <div id="gameOverScreen" class="hidden text-center">
                        <h2 class="text-4xl text-red-500 mb-4">GAME OVER</h2>
                        <div id="rankingPrompt">
                            <p class="mb-4">世界ランキングに登録しますか？</p>
                            <button id="yesSubmitBtn" class="action-btn bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md text-lg mr-2">Yes</button>
                            <button id="noSubmitBtn" class="action-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md text-lg">No</button>
                        </div>
                        <div id="nicknameForm" class="hidden">
                            <input type="text" id="nicknameInput" placeholder="NICKNAME" class="bg-gray-800 text-white text-center p-2 rounded-md mb-2 w-full max-w-xs" maxlength="10">
                            <button id="submitScoreBtn" class="action-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md text-lg">SUBMIT</button>
                        </div>
                         <button id="restartButton" class="hidden action-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-md text-xl mt-4">
                            RESTART
                        </button>
                    </div>
                </div>
            </div>

            <!-- 情報パネル -->
            <div class="w-full md:w-48 flex flex-col gap-4 text-center">
                 <div class="w-full flex flex-row md:flex-col gap-4 justify-around">
                    <div class="bg-gray-800 p-3 rounded-lg flex-1">
                        <h2 class="text-sm text-[var(--accent-color)]">SCORE</h2>
                        <p id="score" class="text-lg mt-1">0</p>
                    </div>
                    <div class="bg-gray-800 p-3 rounded-lg flex-1">
                        <h2 class="text-sm text-[var(--accent-color)]">LINES</h2>
                        <p id="lines" class="text-lg mt-1">0</p>
                    </div>
                    <div class="bg-gray-800 p-3 rounded-lg flex-1">
                        <h2 class="text-sm text-[var(--accent-color)]">LEVEL</h2>
                        <p id="level" class="text-lg mt-1">0</p>
                    </div>
                </div>
                 <div class="bg-gray-800 p-4 rounded-lg hidden md:block">
                    <h2 class="text-sm text-[var(--accent-color)] mb-2">NEXT</h2>
                    <canvas id="nextCanvas" width="80" height="80"></canvas>
                </div>
                <!-- 世界ランキング表示エリア -->
                <div class="bg-gray-800 p-4 rounded-lg">
                    <h2 class="text-sm text-[var(--accent-color)] mb-2">WORLD RANKING</h2>
                    <ol id="rankingList" class="text-left text-sm space-y-1 list-decimal list-inside"></ol>
                </div>
            </div>
        </div>
        
        <!-- モバイル用コントロールボタン -->
        <div class="mt-6 md:hidden w-full max-w-sm mx-auto">
            <div class="flex justify-center mb-2">
                 <button id="rotateBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-lg font-bold">Rotate</button>
            </div>
            <div class="flex justify-between items-center">
                <button id="leftBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">←</button>
                <button id="rightBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">→</button>
            </div>
            <div class="flex justify-center mt-2">
                 <button id="downBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">↓</button>
            </div>
        </div>

    </div>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextContext = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        const overlay = document.getElementById('overlay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const rankingPrompt = document.getElementById('rankingPrompt');
        const nicknameForm = document.getElementById('nicknameForm');
        const yesSubmitBtn = document.getElementById('yesSubmitBtn');
        const noSubmitBtn = document.getElementById('noSubmitBtn');
        const nicknameInput = document.getElementById('nicknameInput');
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        const rankingList = document.getElementById('rankingList');

        // --- 世界ランキング機能 ---
        // 重要：この機能を有効にするには、以下の手順でGoogle Apps ScriptのWebアプリURLを取得し、
        // 下の `SCRIPT_URL` 変数に設定してください。
        //
        // 1. Googleスプレッドシートを新規作成します。
        // 2. 1行目にヘッダーとして `Timestamp`, `Nickname`, `Score` と入力します。
        // 3. 「拡張機能」 > 「Apps Script」を開きます。
        // 4. 以下のコードを貼り付けます。
        /*
        function doGet(e) {
          const ss = SpreadsheetApp.getActiveSpreadsheet();
          const sheet = ss.getSheets()[0]; // 最初のシートを使用
          const data = sheet.getDataRange().getValues();
          data.shift(); // ヘッダー行を削除
          const sortedData = data.sort((a, b) => b[2] - a[2]).slice(0, 10); // スコアで降順ソートし、トップ10を取得
          return ContentService.createTextOutput(JSON.stringify(sortedData))
            .setMimeType(ContentService.MimeType.JSON);
        }

        function doPost(e) {
          try {
            const ss = SpreadsheetApp.getActiveSpreadsheet();
            const sheet = ss.getSheets()[0];
            const params = JSON.parse(e.postData.contents);
            // 簡単なバリデーション
            if (!params.nickname || !params.score || String(params.nickname).length > 10) {
              throw new Error("Invalid parameters");
            }
            sheet.appendRow([new Date(), params.nickname, params.score]);
            return ContentService.createTextOutput(JSON.stringify({status: "success"}))
              .setMimeType(ContentService.MimeType.JSON);
          } catch (error) {
            return ContentService.createTextOutput(JSON.stringify({status: "error", message: error.message}))
              .setMimeType(ContentService.MimeType.JSON);
          }
        }
        */
        // 5. 「デプロイ」 > 「新しいデプロイ」をクリックします。
        // 6. 「種類の選択」で「ウェブアプリ」を選択します。
        // 7. 「アクセスできるユーザー」を「全員」に設定し、「デプロイ」をクリックします。
        // 8. 表示された「ウェブアプリのURL」をコピーし、下の '...' の部分に貼り付けます。
        //
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxlV80HHF5KgQGeefdHsmAO0O0lbUEZ5nqI8B17bt8CyKd0pcQhmKRCA0IJ6TdB64sV/exec';

        // CSS変数から実際の色を取得
        const rootStyles = getComputedStyle(document.documentElement);
        const boardBgColor = rootStyles.getPropertyValue('--board-bg').trim();
        const gridColor = rootStyles.getPropertyValue('--grid-color').trim();

        // ゲームの定数
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const NEXT_BLOCK_SIZE = 20;

        // キャンバスのサイズ設定
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        const TETROMINOES = {
            'I': { shapes: [ [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]], [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]], [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]] ], color: '#00ffff' },
            'J': { shapes: [ [[1,0,0], [1,1,1], [0,0,0]], [[0,1,1], [0,1,0], [0,1,0]], [[0,0,0], [1,1,1], [0,0,1]], [[0,1,0], [0,1,0], [1,1,0]] ], color: '#0000ff' },
            'L': { shapes: [ [[0,0,1], [1,1,1], [0,0,0]], [[0,1,0], [0,1,0], [0,1,1]], [[0,0,0], [1,1,1], [1,0,0]], [[1,1,0], [0,1,0], [0,1,0]] ], color: '#ff7f00' },
            'O': { shapes: [ [[1,1], [1,1]], [[1,1], [1,1]], [[1,1], [1,1]], [[1,1], [1,1]] ], color: '#ffff00' },
            'S': { shapes: [ [[0,1,1], [1,1,0], [0,0,0]], [[0,1,0], [0,1,1], [0,0,1]], [[0,0,0], [0,1,1], [1,1,0]], [[1,0,0], [1,1,0], [0,1,0]] ], color: '#00ff00' },
            'T': { shapes: [ [[0,1,0], [1,1,1], [0,0,0]], [[0,1,0], [0,1,1], [0,1,0]], [[0,0,0], [1,1,1], [0,1,0]], [[0,1,0], [1,1,0], [0,1,0]] ], color: '#800080' },
            'Z': { shapes: [ [[1,1,0], [0,1,1], [0,0,0]], [[0,0,1], [0,1,1], [0,1,0]], [[0,0,0], [1,1,0], [0,1,1]], [[0,1,0], [1,1,0], [1,0,0]] ], color: '#ff0000' }
        };
        const TETROMINO_KEYS = Object.keys(TETROMINOES);
        
        // ゲームの状態変数
        let board, currentTetromino, nextTetromino, score, lines, level, dropCounter, dropInterval, lastTime, isGameOver, animationFrameId, tetrominoBag;

        function createEmptyBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

        // ゲームの状態を初期化
        board = createEmptyBoard();

        function fillTetrominoBag() {
            const shuffledKeys = [...TETROMINO_KEYS];
            for (let i = shuffledKeys.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledKeys[i], shuffledKeys[j]] = [shuffledKeys[j], shuffledKeys[i]];
            }
            tetrominoBag = shuffledKeys;
        }

        function createTetromino() {
            if (!tetrominoBag || tetrominoBag.length === 0) fillTetrominoBag();
            const type = tetrominoBag.pop();
            const tetrominoDef = TETROMINOES[type];
            return { type: type, shape: tetrominoDef.shapes[0], color: tetrominoDef.color, x: Math.floor(COLS / 2) - Math.floor(tetrominoDef.shapes[0][0].length / 2), y: 0, rotation: 0 };
        }

        function draw() {
            if (!context || !board) return;
            context.fillStyle = boardBgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = gridColor;
            for (let x = 0; x < COLS; x++) { for (let y = 0; y < ROWS; y++) { context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); } }
            drawMatrix(board, { x: 0, y: 0 }, context, BLOCK_SIZE);
            if (currentTetromino) { drawMatrix(currentTetromino.shape, { x: currentTetromino.x, y: currentTetromino.y }, context, BLOCK_SIZE, currentTetromino.color); }
        }
        
        function drawMatrix(matrix, offset, ctx, blockSize, colorOverride = null) {
            if (!matrix) return;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = colorOverride || value;
                        ctx.fillRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                        ctx.strokeStyle = boardBgColor;
                        ctx.strokeRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                    }
                });
            });
        }
        
        function drawNext() {
            if (!nextContext || !nextTetromino) return;
            nextContext.fillStyle = boardBgColor;
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            const { shape, color } = nextTetromino;
            const x = (nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2;
            const y = (nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2;
            drawMatrix(shape, {x, y}, nextContext, NEXT_BLOCK_SIZE, color);
        }

        function update(time = 0) {
            if (isGameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) drop();
            draw();
            animationFrameId = requestAnimationFrame(update);
        }
        
        function reset() {
            board = createEmptyBoard();
            fillTetrominoBag();
            currentTetromino = createTetromino();
            nextTetromino = createTetromino();
            score = 0;
            lines = 0;
            level = 0;
            dropInterval = 1000; // 落下速度をリセット
            isGameOver = false;
            updateUI();
            drawNext();
        }

        function drop() {
            if (!currentTetromino) return;
            currentTetromino.y++;
            if (checkCollision()) {
                currentTetromino.y--;
                merge();
                clearLines();
                currentTetromino = nextTetromino;
                nextTetromino = createTetromino();
                drawNext();
                if (checkCollision()) gameOver();
            }
            dropCounter = 0;
        }

        function hardDrop() {
            if (!currentTetromino) return;
            while (!checkCollision()) currentTetromino.y++;
            currentTetromino.y--;
            drop();
        }

        function move(dir) {
            if (!currentTetromino) return;
            currentTetromino.x += dir;
            if (checkCollision()) currentTetromino.x -= dir;
        }
        
        function rotate() {
            if (!currentTetromino) return;
            const { rotation, x: originalX, y: originalY, type } = currentTetromino;
            const newRotation = (rotation + 1) % 4;
            currentTetromino.rotation = newRotation;
            currentTetromino.shape = TETROMINOES[type].shapes[newRotation];
            const kicks = [[0, 0], [-1, 0], [1, 0], [0, -1]];
            if (type === 'I') kicks.push([-2, 0], [2, 0]);
            for (const [kickX, kickY] of kicks) {
                currentTetromino.x = originalX + kickX;
                currentTetromino.y = originalY + kickY;
                if (!checkCollision()) return;
            }
            currentTetromino.rotation = rotation;
            currentTetromino.shape = TETROMINOES[type].shapes[rotation];
            currentTetromino.x = originalX;
            currentTetromino.y = originalY;
        }

        function checkCollision() {
            const { shape, x, y } = currentTetromino;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] !== 0) {
                        const newX = x + col;
                        const newY = y + row;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (board[newY] && board[newY][newX] !== 0)) return true;
                    }
                }
            }
            return false;
        }

        function merge() {
            const { shape, color, x, y } = currentTetromino;
            shape.forEach((row, r) => row.forEach((value, c) => {
                if (value !== 0 && y + r >= 0) board[y + r][x + c] = color;
            }));
        }
        
        function clearLines() {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) if (board[y][x] === 0) continue outer;
                board.splice(y, 1);
                board.unshift(Array(COLS).fill(0));
                linesCleared++;
                y++;
            }
            if(linesCleared > 0) updateScore(linesCleared);
        }

        function updateScore(cleared) {
            score += [0, 40, 100, 300, 1200][cleared] * (level + 1);
            lines += cleared;
            level = Math.floor(lines / 10);
            dropInterval = Math.max(100, 1000 - level * 50);
            updateUI();
        }

        function updateUI() {
            scoreElement.innerText = score;
            linesElement.innerText = lines;
            levelElement.innerText = level;
        }
        
        function startGame() {
            reset();
            overlay.classList.add('hidden');
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = 0;
            dropCounter = 0;
            update();
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            startScreen.classList.add('hidden');
            nicknameForm.classList.add('hidden');
            rankingPrompt.classList.remove('hidden');
            restartButton.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            overlay.classList.remove('hidden');
        }

        async function fetchRankings() {
            if (SCRIPT_URL === 'YOUR_GOOGLE_APPS_SCRIPT_URL_HERE') {
                rankingList.innerHTML = '<li>ランキングURL未設定</li>';
                return;
            }
            rankingList.innerHTML = '<li>Loading...</li>';
            try {
                const response = await fetch(SCRIPT_URL);
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                rankingList.innerHTML = '';
                if(data.length === 0) {
                    rankingList.innerHTML = '<li>まだ記録がありません</li>';
                } else {
                    data.forEach((row, index) => {
                        const li = document.createElement('li');
                        li.textContent = `${row[1]}: ${row[2]}`;
                        rankingList.appendChild(li);
                    });
                }
            } catch (error) {
                console.error('Error fetching rankings:', error);
                rankingList.innerHTML = '<li>取得失敗</li>';
            }
        }

        async function submitScore() {
            const nickname = nicknameInput.value.trim();
            if (!nickname) {
                alert('ニックネームを入力してください。');
                return;
            }
            submitScoreBtn.disabled = true;
            submitScoreBtn.textContent = 'SENDING...';

            try {
                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors', // doPostでリダイレクトされるためno-corsモードを使用
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nickname: nickname, score: score })
                });
                nicknameForm.innerHTML = '<p>スコアを送信しました！</p>';
                await fetchRankings(); // ランキングを更新
            } catch (error) {
                console.error('Error submitting score:', error);
                nicknameForm.innerHTML = '<p>送信に失敗しました。</p>';
            } finally {
                restartButton.classList.remove('hidden');
            }
        }

        // --- イベントリスナー ---
        document.addEventListener('keydown', e => {
            if (isGameOver) return;
            if (e.key === 'ArrowLeft' || e.key === 'a') move(-1);
            else if (e.key === 'ArrowRight' || e.key === 'd') move(1);
            else if (e.key === 'ArrowDown' || e.key === 's') drop();
            else if (e.key === 'ArrowUp' || e.key === 'w') rotate();
            else if (e.key === ' ') { e.preventDefault(); hardDrop(); }
        });

        // モバイル用
        document.getElementById('leftBtn').addEventListener('click', () => move(-1));
        document.getElementById('rightBtn').addEventListener('click', () => move(1));
        document.getElementById('downBtn').addEventListener('click', () => drop());
        document.getElementById('rotateBtn').addEventListener('click', () => rotate());

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => {
             gameOverScreen.classList.add('hidden');
             startGame();
        });

        yesSubmitBtn.addEventListener('click', () => {
            rankingPrompt.classList.add('hidden');
            nicknameForm.classList.remove('hidden');
        });

        noSubmitBtn.addEventListener('click', () => {
            rankingPrompt.classList.add('hidden');
            restartButton.classList.remove('hidden');
        });

        submitScoreBtn.addEventListener('click', submitScore);

        // --- 初期化 ---
        draw();
        fetchRankings();
    </script>
</body>
</html>

